{"version":3,"file":"static/webpack/static/development/pages/write-chinese.js.57ac3a48706e24253a33.hot-update.js","sources":["webpack:///./components/WriteCharactor/index.tsx"],"sourcesContent":["import { useState, useCallback, useEffect, useLayoutEffect } from \"react\";\nimport { Pane, Button, IconButton } from \"evergreen-ui\";\nimport WriteCharactorSearch from \"@components/WriteCharactor/WriteCharactorSearch\";\n\nlet time = 0;\nlet reqFrame;\nlet paths = [];\nexport default function(props) {\n  const LAYOUT_SIZE = props.size || 600;\n  const [char, setChar] = useState(\"\");\n  const onSearch = slug => {\n    slug =  slug.slice(0, 1);\n    if (slug && props.dict[slug]) {\n      paths = JSON.parse(JSON.stringify(props.dict[slug]));\n      location.hash = \"#/\" + slug;\n    } else {\n      paths = [];\n    }\n    setChar(slug);\n  };\n  const draw = startTime => {\n    if (!__CLIENT__) {\n      return;\n    }\n    var canvas = document.getElementById(\"canvas\") as HTMLCanvasElement;\n    var ctx = canvas.getContext(\"2d\");\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.lineWidth = 1;\n    //画田字格\n    var drawBoard = function() {\n      ctx.setLineDash([]);\n      ctx.strokeStyle = \"red\";\n      for (var i = 0; i < 3; i++) {\n        ctx.beginPath();\n        ctx.moveTo(0 + i * 300, 0);\n        ctx.lineTo(0 + i * 300, 300 * 3 - 0);\n        ctx.stroke();\n        ctx.moveTo(0, 0 + i * 300);\n        ctx.lineTo(300 * 3 - 0, 0 + i * 300);\n        ctx.stroke();\n      }\n      // X\n      ctx.beginPath();\n      ctx.setLineDash([5, 15]);\n      ctx.moveTo(0, 0);\n      ctx.lineTo(600, 600);\n      ctx.stroke();\n      // X\n      ctx.beginPath();\n      ctx.setLineDash([5, 15]);\n      ctx.moveTo(600, 0);\n      ctx.lineTo(0, 600);\n      ctx.stroke();\n\n      ctx.closePath();\n    };\n    drawBoard();\n    const drawWord = thepaths => {\n      if (startTime !== time) {\n        paths = [];\n        return;\n      }\n      var vertices = [];\n      if (thepaths.length > 0) {\n        vertices = thepaths.shift();\n      } else {\n        return;\n      }\n      // calculate incremental points along the path\n      var points = calcWaypoints(vertices);\n      // extend the line from start to finish with animation\n      // calc waypoints traveling along vertices\n      function calcWaypoints(vertices) {\n        var waypoints = [];\n        var fps = 50;\n        var len = vertices.length;\n        if (len > 3) {\n          fps = 40;\n        }\n        for (var i = 1; i < len; i++) {\n          var pt0 = vertices[i - 1];\n          var pt1 = vertices[i];\n          var dx = pt1[0] - pt0[0];\n          var dy = pt1[1] - pt0[1];\n          for (var j = 0; j < fps; j++) {\n            var x = pt0[0] + (dx * j) / fps;\n            var y = pt0[1] + (dy * j) / fps;\n            waypoints.push({\n              x: x,\n              y: y\n            });\n          }\n        }\n        return waypoints;\n      }\n      var t = 1;\n      function animate() {\n        if (startTime !== time) {\n          cancelAnimationFrame(reqFrame);\n          return;\n        }\n        ctx.lineCap = \"round\";\n        ctx.lineWidth = 15;\n        ctx.strokeStyle = \"#000\";\n        ctx.beginPath();\n        ctx.moveTo(points[t - 1].x, points[t - 1].y);\n        ctx.lineTo(points[t].x, points[t].y);\n        ctx.stroke();\n\n        if (t < points.length - 1) {\n          reqFrame = requestAnimationFrame(animate);\n        } else {\n          drawWord(thepaths);\n        }\n        t++;\n      }\n      animate();\n    };\n    if (char && paths && paths.length) {\n      drawWord(paths);\n    }\n  };\n  useEffect(() => {\n    let path = decodeURIComponent(location.hash.slice(2));\n    onSearch(path);\n    time = new Date().getTime();\n    draw(time);\n  }, [char]);\n  return (\n    <Pane>\n      <WriteCharactorSearch char={(set)=> {set(char)}} onSearch={onSearch}></WriteCharactorSearch>\n      <Pane className=\"clearfix\" paddingTop={100}>\n        <canvas id=\"canvas\" width={LAYOUT_SIZE} height={LAYOUT_SIZE}></canvas>\n      </Pane>\n    </Pane>\n  );\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAFA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA,iBAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;;;;A","sourceRoot":""}